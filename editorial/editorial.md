---
layout: default
---

# 2024 全國資訊學科能力競賽 解說（NHSPC2024 Editorial）

## A. Taxi

### Subtask 1

不管怎麼指派，所有計程車都是從左邊往右邊開，因此總距離都是

\\[ \sum_{i=1}^n p_i - \sum_{i=1}^n t_i \\]

### Subtask 2

一個直覺的想法是，越左邊的計程車就應該要負責越左邊的人，這樣的話把 $t$、$p$ 都由小到大排序後，$\sum \|p_i-t_i\|$ 就是答案。

先把 $p,t$ 都按小到大排序。假設有兩輛計程車 $i < j$ 分別負責路人 $a > b$，考慮它們交換之後對叫車距離總和造成的變化，會發現交換之後肯定不會比較差，因此這個作法是正確的。仔細證明一下，有以下幾種可能：

- $[p_b,p_a]$ 和 $[t_i,t_j]$ 不相交或只在端點相交：
    - $p_b \leq p_a \leq t_i \leq t_j$
    - $t_i \leq t_j \leq p_b \leq p_a$
- $[p_b,p_a]$ 和 $[t_i,t_j]$ 互相包含
    - $t_i \leq p_b \leq p_a \leq t_j$
    - $p_b \leq t_i \leq t_j \leq p_a$
- $[p_b,p_a]$ 和 $[t_i,t_j]$ 相交
    - $t_i \leq p_b \leq t_j \leq p_a$
    - $p_b \leq t_i \leq p_a \leq t_j$

同一類的兩種狀況只要 $p,t$ 互換就長一樣，所以我們只考慮每一類的第一種可能。

- $p_b \leq p_a \leq t_i \leq t_j$：本來的叫車距離是 $(t_i-p_a)+(t_j-p_b)$，交換負責對象後是 $(t_i-p_b)+(t_j-p_a)$，跟本來一樣。
- $t_i \leq p_b \leq p_a \leq t_j$：本來的叫車距離是 $(p_a-t_i)+(t_j-p_b)$，交換後是 $(p_b-t_i)+(t_j-p_a)$，$p_b-p_a \leq 0 \leq p_a - p_b$ 所以不比本來差。
- $t_i \leq p_b \leq t_j \leq p_a$：本來是 $(p_a-t_i)+(t_j-p_b)$，交換後是 $(p_b-t_i)+(p_a-t_j)$，$p_b-t_j \leq 0 \leq t_j-p_b$ 所以不比本來差。

---

## B. Paint

以下定義 $d$ 為 $\|S\|$ 的字元種類數。

### Subtask 1

如果 $d=1$，答案是 $0$。

否則 $d=2$，我們只需要算出把一種字元全部搬到最前面，以及全部搬到最後面所需要的步數，最後輸出比較小的那方。

時間複雜度：$O(\|S\|)$。

### Subtask 2

這個子題開始，會使用到一個關鍵觀察：
- 假設我們將每個字元 $c$ 賦予一個正整數的值 $a_c$，這個值代表最後字串中，該字元為從頭開始第 $a_c$ 個出現的字元。要轉變最後字串所需的步數恰好為起始字串中的逆序數對個數，即 $a_{S_1},a_{S_2},\ldots,a_{S_{\|S\|}}$ 的逆序數對個數。

因此我們可以直接枚舉 $d!$ 種最後的字串，然後 $O(\|S\|^2)$ 去比對任兩個 $S_i,S_j$ 是否為逆序關係來得到逆序數對的總數。

時間複雜度：$O(d!\cdot \|S\|^2)$。

### Subtask 3

我們想辦法加速算逆序數對個數。可以觀察到逆序數對可以拆成每兩種字元之間的逆序數對總和之總和，因此我們可以考慮事先算出對於任兩種字元 $c,c'$，兩者之間的逆序（$c$ 在 $c'$ 前面）數對個數 $\mathrm{count}(c,c')$。

每個 $\mathrm{count}(c,c')$ 可以用以下的方法算：
- 從頭掃過整個 $S$，過程中紀錄 $c$ 出現的次數，每次遇到 $c'$ 就把當前 $c$ 出現的次數加到 $\mathrm{count}(c,c')$ 中。

這部分如果直接對每兩個字元做會是 $O(d^2\cdot\|S\|)$。我們可以透過以下方法加速達到 $O(d\cdot\|S\|)$：
- 只掃過一次 $S$，然後同時記錄所有字元出現的次數，並且對於每個 $S_i$，同時更新所有的 $\mathrm{count}(c,S_i)$


對於每種最後的字串，我們考慮所有 $c,c'$，如果 $c$ 比 $c'$ 晚出現在最後的字串，就將逆序數對個數加上 $\mathrm{count}(c,c')$。

時間複雜度：$O(d!\cdot d^2+d\cdot \|S\|)$。

### Bonus

本題的重點在逆序數對的觀察以及預處理字元種類之間的貢獻，因此 $d$ 的範圍沒有刻意刁難選手。事實上，這題還能再進一步加速，有興趣的讀者可以想想看 $d\le 20$ 的話該如何加速。


---

## C. Nums

以下令 $L$ 為 $a_i$ 的最大位數。

先考慮怎麼實作出 $P(a,b)$，$P(a,b)=\text{True}$ 只有兩種可能：$a$ 跟 $b$ 長得一模一樣，或是長度一樣而且恰有兩個位數不一樣，這兩個位數還剛好是交換的，這些條件可以用 $O(L)$ 的時間檢查。

答案呼之欲出：對於所有的 $\binom{n}{2}$ 對數字檢查 $P(\cdot,\cdot)$，可以想像有一張圖，每個節點對應到一個 $a_i$，$u,v$ 間有邊若 $P(a_u,a_v)=\text{True}$，答案是這張圖的連通塊數量，可以使用 BFS 計算答案，總時間複雜度是 $O(n^2L)$。

### Bonus

本題存在時間複雜度為 $O(nL+n^2)$ 的作法。

---

## D. Cover

### 有關於 Output Only 題型

儘管做為 IOI 每年機器測試必定會出現給選手熟悉的題型，Output Only 在 IOI 正式賽中出現的次數可說是少之又少。在 2017 年以前，Output Only 都是以 NP-hard 的題目做為原型出現，並考驗選手設計啟發式演算法的能力。

但到了 2018 年後，IOI 似乎有意讓提示過於困難的題目出成 Output Only 的形式，而這些題目本身是完全可做的題目。我們猜測，由於在這種狀況下想設計子任務來引導選手找到正確解答，可能會讓子任務的說明變得非常冗長甚至抽象，為了讓選手也能透過觀察「在特定狀況下，特定作法的解答」來獲得引導，Output Only 題的用意便是不仰賴文字的說明，而是直接將特定的測試資料攤開給選手解決後，讓選手找出整道題目的做法。

因此，面對 Output Only 題型，對測試資料的觀察是非常重要的，本題對子任務的設計有特別朝著這個方向做準備，並比照 IOI 提供「視覺化工具」讓選手進行測試資料的觀察。

若選手未來要針對 Output Only 題型做練習，本題也許會是一個絕佳的範例供選手了解該題型的做題策略，以下在提供解答的同時，會試著一併解釋設計該子任務的目的。

### Subtask 1~4

透過題本上的範圍可以知道，這四筆的範圍都非常的小，若選手在賽中騰出時間撰寫暴力搜尋、或是認真手構是很有機會拿滿的。

在本題中，撰寫小區塊的暴力搜尋工具是非常重要的，尤其是子任務 4 的出現，也是希望選手能先寫一個暴力搜尋工具出來，供後續解題用。

### Subtask 5

在子任務 5 後，範圍很直接的被拉大了，但子任務 5 還能夠使用本題的視覺化工具完整瀏覽，若選手打開該題的圖片觀察，可以發現本子任務的性質：
- 每一個 $5\times 5$ 區塊都只有一個特殊格子

這樣單純的子任務，其實是在試圖暗示**所有只有一個特殊格子的區塊都獨立可解**，也就是說，只要單獨搜尋每一個子區塊就可以得到花費為 $0$ 的解答了！透過子任務 1 寫好的爆搜工具，就可以輕鬆拿下該子任務。

### Subtask 6

同樣地，若選手打開該題的圖片觀察，可以發現本子任務的性質：
- 若把方格黑白染色，所有黑色 $5\times 5$ 區塊都有兩個特殊格子、所有白色 $5\times 5$ 區塊都只有一個特殊格子

想當然的，並不是每一種 $5\times 5$ 區塊都可以獨立解完，但透過子任務 5 我們知道，每一個白色區塊都是獨立可解的，當有一些黑色區塊獨立不可解，這表示他勢必得找一個鄰居共用積木，而，若他**僅依靠一個鄰居就完事**，不就代表這是最佳花費嗎？

而答案是肯定的。事實上，任何一種黑白格子的配對方式都能保證存在一組完整覆蓋的方式，選手只需要針對那些無法獨立可解的黑色格子，隨意賦予他一格白色鄰居，透過子任務 2 的暴搜工具完成配對後就可以拿下該子任務的滿分。

### 重要觀察整理

如果完成了子任務 5 和 6，選手可以試圖開始暴力搜尋哪些狀況是沒有解答的。

子任務 6 的存在、包含該子任務特別高的分數，都是希望能強烈暗示以下性質：
- 所有由兩個 $5\times 5$ 區塊拼接在一起的棋盤皆能獨立填滿。

這同樣暗示著，**試圖將兩個區塊配對在一起**，是非常重要的一個考量點。

更完整地說，所有 $5\times 5$ 區塊總是能分成以下兩種形式：
- 獨立可解的
- 獨立不可解的

而對於那些獨立不可解的區塊，我們總是得幫他們找到一些鄰居，增加花費來讓他們變得可解。

問題來了，假設獨立不可解的區塊有 $k$ 個，那最小花費一定不會低於 $k$ 嗎？

並不是！

由於花費的定義「共用積木的區塊對」，因此，每花費 $1$ 就有可能抵銷兩個獨立不可解的區塊，因此，最佳的花費下界其實會是 $\left\lceil \frac{k}{2}\right\rceil$。

或是，更準確的說，如果我們將所有獨立不可解的區塊當成 $k$ 個點、可以配對的相鄰區塊建邊，若這張圖的[**最大匹配**](https://zh.wikipedia.org/zh-tw/%E5%8C%B9%E9%85%8D_(%E5%9B%BE%E8%AE%BA))是 $M$，則最佳花費下界為 $k - \|M\|$。

因此，若我們能夠構造出這樣一組解答，就可以自信的宣稱這是最佳花費！
 
### Subtask 7

本子任務相對特殊，因為區塊們形成一條鏈！

可以發現，在這個子任務中，區塊是沒任何規律以可解、不可解區塊交錯出現，但有了前面的重要觀察，答案似乎呼之欲出：
- 考慮每一個不可解區塊的連續區間，若該區間長度為偶數，則他自己可以完美匹配；若該區間長度為奇數，則匹配完後會有一個不可解區塊落單，得隨意抓一個可解區塊當鄰居增加花費。

當然，似乎有可能存在有同一個鄰居被左右兩個連續區間爭奪的狀況，但幸運的是，遇到此狀況時，只要其中一個連續區間乖乖去抓另一側的鄰居就可以通過本子任務。

子任務 7，由於匹配相對簡單，同時也是用來給選手驗證「最大匹配」的理論。

### Subtask 8, 9

如果足夠大膽，我們不妨做出以下猜測：
- 肯定存在一組花費 $k-\|M\|$ 的構造

我們不妨考慮以下的構造演算法：
- 同樣，將所有獨立不可解的區塊當成 $k$ 個點、可以配對的相鄰區塊建邊
- 對這 $k$ 個點解最大匹配
    - 注意到這裡，該圖會是一張二分圖，可以使用[二分圖最大匹配](https://oi-wiki.org/graph/graph-matching/bigraph-match/)演算法來找到最大匹配，執行最單純的、IOI 範圍內允許的 $O(VE)$ 演算法即可。
- 此時會剩下 $k-2\|M\|$ 個點尚未有匹配點，我們接著嘗試擴增稍早建好的圖，也就是加入那些獨立可解的區塊、同時也把所有相鄰的邊建出來
- 若讀者稍微了解過匹配演算法內「增廣路徑」的概念，就可以發現，在擴增的圖上對每個未匹配點執行找增廣路徑的演算法，每次增廣即可以將「獨立可解區塊」視為增廣路徑的端點進行匹配的增廣，也就可以為剩下 $k-2\|M\|$ 個點找到匹配點。

該演算法最終會在 $O(nm)$ 個點、$O(nm)$ 條邊的二分圖上執行兩次最大匹配演算法，當使用 $O(VE)$ 的匹配演算法，其時間複雜度為 $O((nm)^2)$。

若沒有想到如何好好處理未匹配點，子任務 8 的設計會讓未匹配點周圍有相當充足的空間可以找到相鄰的獨立可解區塊可以做匹配，在該子任務執行啟發式的任意匹配演算法應能通過。

### Subtask 10

可惜子任務 8, 9 並沒有幫助我們做完整題，如果選手大膽使用前面的匹配作法後，順利通過關鍵子任務 8, 9，就會不小心在這筆子任務摔一跤。

事實上，子任務 1, 3 都在暗示著該情況的發生：還是有特殊情況不能靠著匹配完成的。而當發生這種狀況時，肯定會把整個 $n\times m$ 的方格都配到上限，並因為 $n\times m$ 是奇數，留下孤單的一個方格沒有人配對。

不過，如果發生這種情況，不就表示答案是 $\left\lceil \frac{n\times m}{2}\right\rceil$ 嗎？因此，我們可以先在角落抓一個 $5\times 15$ 區塊去解子任務 3，並隨意重新匹配整個方格，就可以達到這個下界了。

咦？隨意抓一個 $5\times 15$ 區塊會不會無解？沒問題，儘管賽中無法驗證，只要好好暴搜一遍就可以發現：$5\times 15$ 的區塊永遠都有解。

### 對於整道題目本身

而作為匹配作法的特殊情況，實際上子任務 10 的設計又更為直接一點：所有區塊都是不可解的方格，因此比一般狀況又更簡單一點，也許這十個子任務並沒有幫助我們卡掉可能錯誤的解。不過，為了解決以下子任務所寫出的程式碼，總是能夠重新組合後得到以下演算法：
- 先進行一遍 General 的匹配作法
- 當匹配作法失敗時，隨意給出一組 $\left\lceil \frac{n\times m}{2}\right\rceil$ 的構造

就可以完整在 $O((nm)^2)$ 的時間內完整解決這題了！沒錯，這題可不是什麼 NP-hard 問題，而且正常實作的程式碼甚至也可以好好的在 1 秒內搞定 $n\times m\leq 1600$ 的測試資料！當然，使用 [Hopcroft–Karp algorithm](https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm) 更是能進一步把時間複雜度優化至 $O((nm)^{1.5})$，不過這就不在 IOI 的範圍內了。

#### 完整證明

也許讀者看完前面做法會有嚴謹性上的疑慮，因此剩下這個小節就用來給出完整的證明吧！

前面演算法最大的疑慮點就是，為何匹配演算法失敗時就可以保證答案為 $\left\lceil \frac{n\times m}{2}\right\rceil$？以下定理可以給出答案。

**[定理 1]**：給定一 $n\times m$ 方格圖，考慮任意一組不一定最大的匹配，當存在至少兩個未匹配點時，任意一個未匹配點皆能找到一條增廣路徑。

**[定理 1 的證明]**

使用反證法。

考慮任意一個找不到增廣路徑的未匹配點 $x$，對 $x$ 執行交替路徑的搜尋，此時 $x$ 會遍歷出一連通塊 $S$。

將方格圖黑白染色，不失一般性假設 $x$ 為黑色，則因為 $x$ 找不到增廣路徑，$S$ 的外圍只有可能都是白色的匹配點、或者是邊界。我們定義一個 $S$ 中的格子 $v$ 是**輪廓**若 $v$ 跟一個不在 $S$ 中的格子相鄰，注意在方格邊界上的格子若沒有和不在 $S$ 裡的格子相鄰，就不是輪廓。$S$ 中的所有輪廓格子都是白色。

$S$ 中的每個白色格子都有一個和它匹配的黑色格子，再算上 $x$ 這個黑色格子，得出 $S$ 中的黑色格子數量恰好比白色多 1。

先來一個簡單的 case：如果 $S$ 不包含任何方格邊界上的格子，這代表 $S$ 最外圍的所有格子（都是輪廓）都是白色格子，否則交替路徑會可以走出去。如果一橫排一橫排的看，每一段 $S$ 中的極長連續格子都會是「白黑白黑……黑白黑白」，白色數量比黑色多 1，得出 $S$ 中的白色格子數量嚴格大於黑色格子，跟剛才說的「黑色比白色多 1」矛盾。

（注意所謂「$S$ 的外圍」指的是 $S$ 中，在方格邊界，或者跟非 $S$ 格子相鄰的格子，如果 $S$ 內部有洞，也就是有個區域完全被 $S$ 包住的話，在洞周圍的格子也算 $S$ 的外圍。洞在這裡還不會造成什麼問題，之後我們會更進一步證明洞不存在。）

要是 $S$ 包含方格邊界的格子，那就可能不是這樣了，例如 $S$ 長成
```
-oxo
oxox
```
這是 $2 \times 4$ 方格，`o` 是白色、`x` 是黑色，`-` 代表不在 $S$ 裡，這個 $S$ 的輪廓都是白色，但黑色數量確實比白色多 1。這個例子只是簡單說明「輪廓都是白色」並不能直接讓我們得出「白色多於黑色」這個性質，這個例子裡的 $S$ 實際上根本走不出來。

要能處理 $S$ 包含方格邊界的狀況，我們要先探究一下匹配的本質。

**[引理 1]**：令 $M$ 為目前匹配、$M^\*$ 是某一組最大匹配，把 $S$ 拔掉後剩下的部分，存在一組 $\|M^\*\|-\left\lfloor\frac{\|S\|}{2}\right\rfloor$ 匹配。

**[引理 1 的證明]**

考慮 $H=M \oplus M^\*$，也就是兩個匹配邊集合的對稱差。和標準的 Berge's theorem 證明類似，$H$ 中的每個節點度數至多是 2，所以每個連通塊都是一條鏈或一個環，其中環在 $M$ 和 $M^\*$ 上都是交替環，而鏈必定是 $M$ 的增廣路徑，考慮一條這樣的鏈 $P$。

令 $G$ 是一張**有向**二分圖，左側點對應到黑色格子、右側點對應到白色格子，每對相鄰格子之間都有一條邊，若在 $M$ 是匹配邊則往左定向，否則往右定向。$M$ 的增廣路徑與 $G$ 的一條從未匹配黑色格子到未匹配白色格子的路徑一一對應，所以 $P$ 也是 $G$ 上的一條路徑。$S$ 恰好是所有 $x$ 在 $G$ 上能走到的所有點。

若 $P$ 中包含任何 $S$ 中的節點，這代表存在一條從 $S$ 中的節點 $v$ 走到一個未匹配白點的路徑，所以存在 $x$ 到那一個未匹配白點的路徑，得出有一條 $x$ 出發的增廣路徑，矛盾。因此，$H$ 中的所有鏈必不包含任何 $S$ 中的點。

留下 $H$ 中的所有環 $H'$，把 $M^\*$ 替換成 $M^\* \oplus H'$、$H$ 換成新的 $M \oplus M^\*$，$M^\*$ 還是一組最大匹配，而且 $H$ 中的每條邊端點都不在 $S$ 裡。$M \oplus H$ 就是 $M^\*$，而且還沒有動到任何 $S$ 裡的點，得出我們可以在完全不動 $S$ 的情況下讓 $M$ 變成最大匹配，$S$ 自己裡面的匹配數是 $\left\lfloor \frac{\|S\|}{2} \right\rfloor$，所以 $S$ 外面就得是 $\|M^\*\|-\left\lfloor \frac{\|S\|}{2} \right\rfloor$。

**[引理 1 證明結束]**

**[引理 1 推論]**
1. 如果 $n \times m$ 是偶數，那一定有 $x$ 出發的增廣路徑。
2. 如果 $n \times m$ 是奇數，拔掉 $S$ 後的每個連通塊 $C$，都滿足 $C$ 的大小是偶數，且存在完美匹配。

不難發現真正的最大匹配一定是 $\lfloor \frac{n \times m}{2} \rfloor$，第一點來自 $n \times m$ 是偶數時，每個點在最大匹配都得是匹配點，但引理 1 會告訴我們 $x$ 可以不是匹配點，造成矛盾。而第二點來自 $n \times m$ 是奇數時，$x$ 以外的點都一定要是匹配點。

我們將 $S$ 以及把 $S$ 拔掉後的每個連通塊稱作一個**區域**，每個區域都是連通的（但或許有洞），和前面的定義相似，一個區域 $C$ 中的格子 $v$ 是這個區域的輪廓若 $v$ 和一個不在 $C$ 裡的格子相鄰。$S$ 的輪廓一定是白色，非 $S$ 區域的輪廓一定是黑色。因此，我們的目標是做到以下兩件事的其中一件

- 證明 $S$ 裡白色格子數量 $>$ 黑色格子數量，這樣就會和 $S$ 裡黑色是白色多 1 的已知事實矛盾。
- 證明非 $S$ 區域裡的黑白格子不一樣多，這樣就會做不出完美匹配，和引理 1 矛盾。

我們證明的方法都是「輪廓顏色的格子數量比另一種多」。

**[觀察]：任一個區域都連通、有碰到方格邊界，而且沒有洞。**

因為有洞的話，洞內部那個區域就是一個不包含方格邊界的區域，前面推論過了，這樣的區域中，輪廓顏色的格子會比另一種多。所以，每個區域都有碰到方格邊界，而且沒有洞。

要處理區域碰到方格邊界的狀況，我們需要提出稍微強一點的性質：先定義一個區域 $C$ 的格子 $v$ 是**橫向輪廓**若 $v$ 的左右至少有個格子不在 $C$ 裡、是**直向輪廓**若上下至少有個格子不在 $C$ 裡。

**[引理 2]**：如果 $n,m > 1$，一個區域 $C$ 的每個 row 都有橫向輪廓，**或是**每個 column 都有直向輪廓，則輪廓顏色的格子比另一種顏色多。

**[引理 2 的證明]**

$C$ 裡每一段直的或橫的極長連續格子，端點只能是輪廓或方格邊界。每個 row 都有橫向輪廓的話，每段橫的極長連續格子都有至少一個端點是輪廓，至少讓我們得出輪廓顏色的數量 $\geq$ 另一種顏色。只要存在一段橫的極長連續格子兩端都是輪廓，那這個關係就變成 $>$。

要是每一段橫的極長連續格子都有其中一個端點是方格邊界，考慮任意一段橫的極長連續格子，它靠方格邊界的那個格子要是是輪廓顏色，那同樣會得出輪廓顏色 $>$ 另一種顏色，否則，因為它不是輪廓，上下的格子（如果有）都必須在 $C$ 裡，而包含那些格子的橫的極長連續格子都是「靠方格邊界的那個格子是輪廓顏色」。

直的版本同理。

**[引理 2 證明結束]**

$n=1$ 或 $m=1$ 的狀況不難驗證定理直接就是好的，所以我們就不管它了。

所以只要任何區域滿足引理 2，就會得到矛盾。引理 2 條件的反面敘述就是「每個區域都要佔據某一整個 row 或一整個 column」，注意如果有一個區域佔據了一個 row，那就不可以有別的區域佔據一個 column，我們不失一般性假設每個區域都有佔據一個 row。

因為每個區域各自連通，又是以 $S$ 分開來的，令 $r$ 是任意一個 $S$ 佔據的 row，一定是 $r$ 以上有至多一個非 $S$ 區域、以下有至多一個非 $S$ 區域，由於上下的區域都會再各佔據一個 row，要是有的話，最上面那個 row 屬於上面的區域，最下面則屬於下面的區域。由於前提假設存在一個 $x$ 以外的未匹配點，所以至少存在一個非 $S$ 區域，不失一般性假設上面的區域存在，就直接叫它 $C$。

**[引理 3]**：$S$ 中的任何一個白色格子，至少有兩個在 $S$ 中的相鄰黑色格子。

**[引理 3 的證明]**

$S$ 中的 $x$ 出發的交替路徑都是「黑 白黑 白黑 白黑 ...」，白色的下一個才是跟它匹配的黑色格子，所以白色格子必定是要從一個不和它匹配的黑色格子走來。

**[引理 3 證明結束]**

最左邊的 column 上，一定存在一個格子 $(r',1)$（$1 < r' \leq r$）滿足它在 $S$ 裡、它上面的格子 $(r'-1,1)$ 在 $C$ 裡，因為 $(r',1)$ 剩下的黑色鄰居就只有下面和右邊的格子了，根據引理 3，它們都要在 $S$ 裡，而因為所有 $S$ 裡黑色格子的相鄰白格子都也會在 $S$ 裡，所以 $(r',1)$ 右上角的 $(r'-1,2)$ 在 $S$ 裡，可以理解成在這邊 $S$ 的輪廓會先往右上長，要是我們沿著這個方向走，輪廓是不可以右轉的，不然會造成有一個白色格子只有一個黑色鄰居，違反引理 3。要是輪廓左轉了，那最後一定會圍出一個不佔據任何 row 的區域，違反引理 2。所以這個輪廓就只能一路往右上長，又不能摸到上邊界，一路長到右邊界的話，輪廓上最後的格子只有一個黑鄰居，矛盾。

到這裡，我們就成功證明了「找不到一條 $x$ 出發的增廣路徑」是不可能發生的事情。

**[定理 1 證明結束]**

有了定理 1，匹配演算法就可以不斷的幫不可解區塊找到增廣路徑，但在 $n\times m$ 是奇數時，有可能到了剩最後一個點想找增廣路徑卻無法增廣，此時也顯而易見的答案即為 $\left\lceil \frac{n\times m}{2}\right\rceil$。

---

## E. Huaguo

### Subtask 1

每次只能發一顆桃子，很明顯只要發到每個猴子的桃子數都是 $a_n$ 就好，答案是 $na_n - \sum a_i$。

### Subtask 2

每次要發 $n-1$ 顆桃子，為了避免相對剝奪感，每次只能是發個 $n-1$ 隻猴子一顆桃子、剩下一隻不發，可以想成是剩下的那一隻相對地被沒收了一顆桃子，所以最佳作法是把每隻猴子的桃子都沒收到到剩下 $a_1$，答案是 $\sum a_i - na_1$。

### Subtask 3

首先，如果 $k < n$，那每次發桃子肯定是發給 $k$ 隻不同的猴子各一顆，如果 $k \geq n$，那就是發給 $k \bmod n$ 隻猴子 $\lfloor \frac{k}{n} \rfloor + 1$ 顆桃子、剩下每隻發 $\lfloor \frac{k}{n} \rfloor$ 顆桃子，畢竟我們的目標只是讓每隻猴子的桃子數量都一樣，所以可以想成是我們只發給 $k \bmod n$ 隻猴子每人一顆桃子。接下來我們都假設 $k < n$。

一個很直覺的想法是，每一次發的 $k$ 個桃子都是給當下桃子數量最少的 $k$ 隻猴子。

**[引理 1]**：如果存在一種發放桃子的方法，使得最終每隻猴子手上的桃子數量都是 $p$，那麼一定可以用不斷發 $k$ 個桃子給當下桃子數量最少的 $k$ 隻猴子的方式，讓每隻猴子都有恰 $p$ 個桃子。

**[引理 1 的證明]**

定義 $c_i:=p-a_i$，也就是第 $i$ 隻猴子需要被發的桃子總數。由於我們已經假設 $p$ 是一個可以達成的目標，所以會滿足：
1. 存在一個整數 $t$ 滿足 $\sum c_i=tk$，$t$ 是發桃子的次數。
2. 每隻猴子多拿到最多 $t$ 個桃子，所以 $0 \leq c_i \leq t$。

我們證明只要 $p$ 和它定義出來的 $c_i$ 滿足上述兩個條件就一定可以這樣做，考慮對於 $t$ 使用數學歸納法。

如果 $t=0$，什麼也不用做。

如果 $t>0$ 而且 $t$ 少 1 的時候可以用這個方法發桃子，根據我們的作法，第一次發桃子時是發給 $c_i$ 最大（$a_i$ 最小）的 $k$ 隻猴子，在這之後的過程可以當成是一個全新的問題，這次發桃子之後第 $i$ 隻猴子還需要的桃子數量記作 $c'_i$，還需要發的總次數是 $t'=t-1$，驗證一下這個新問題是不是還符合上述條件：

- 如果 $i$ 是有被發到桃子的猴子，那麼 $c'_i=c_i-1$，他要滿足 $0 \leq c'_i \leq t$ 的條件，就要滿足 $c_i \geq 1$。最大的 $k$ 個 $c_i$ 一定都 $\geq 1$，否則 $\sum c_i$ 最多是 $k-1$，和 $\sum c_i =tk \geq k$ 矛盾。
- 如果 $i$ 沒有被發到桃子，那麼 $c'_i=c_i$，$0 \leq c'_i \leq t$ 的條件會被滿足。
- 根據以上兩點，我們也會知道 $\sum c'_i = \sum c_i - k= (t-1)k = t'k$。
  
因此，這次發完桃子後的情形是一個滿足我們要求的條件、$t$ 少 1 的問題，根據歸納法的假設，我們可以用上述方法發完桃子。

根據數學歸納法，只要 $t \geq 0$ 就可以使用上述方法發桃子。

**[引理 1 證明結束]**

模擬這個過程直到所有猴子的桃子數量都一樣為止，可以輕鬆地在 $O(t \times n \log n)$ 的時間完成，$t$ 是答案。注意到這個子任務的限制中有「若最少天數存在，則不超過 $10^4$」，模擬超過 $10^4$ 後就直接輸出 `poor monkeys`，即可通過本題。

### Subtask 4

這個子任務的限制中除了輸入數字的範圍外，還有「對於那些最少天數存在的測試資料，最少天數的總和不超過 $10^5$」，我們先討論如何處理最少天數存在的狀況。

因為最少天數總和有個不大的限制，只要我們可以很快地模擬發一次桃子，就可以解決問題。猴子是按照 $a_1 \leq a_2 \leq \dots \leq a_n$ 排序時（就和題目輸入限制一樣），要是我們直接把桃子發給前 $k$ 隻猴子，那發完之後可能會需要改變猴子的順序（當 $a_k=a_{k+1}$ 時），會變得不太好維護，所以應該要試著在發完桃子後，還是保持 $a_i \leq a_{i+1}$。

對於猴子 $i$，如果 $a_i < a_k$，那他當然要被發到桃子，假設這些肯定會被發到桃子的猴子有 $x$ 個，接下來我們要在 $a_i=a_k$ 的猴子 $i$ 之中選 $x$ 個發桃子，既然要保持發完後 $a_i$ 還是遞增，那當然就是發給 $a_i=a_k$ 的猴子裡最後 $k-x$ 隻。

維護 $a_i$ 的變化就變成了一個資料結構問題，每次發桃子都是把 $a_1,\dots,a_n$ 的某兩個區間加上 1。考慮維護相鄰猴子的桃子數量差分 $d_i := a_i-a_{i-1}$，特別令 $d_1=\infty$。$x$ 是滿足 $x < k$、$d_{x+1} > 0$ 的最大值，而最後一個 $a_i=a_k$ 的 $i$ 是 $i \geq k$、$d_{i+1} > 0$ 的最小值，每次區間加值至多只會改變差分的兩個數值，使用 `std::map` 維護非 $0$ 的 $d_i$ 即可在 $O(\log n)$ 的時間完成一次發桃子。另一種實作方法是用兩個 stack 分別維護 $k$ 左側和右側的 $d_i$，需要知道以及會改變的$d_i$ 都會是最靠近 $k$ 的非 0 $d_i$（或新出現的），只要用 stack 操作就可以維護了，這樣一來只要 $O(1)$ 的時間就能模擬一次發桃子，也比 `std::map` 的方法好寫。

如果無解（最少天數不存在），能不能模仿上個子任務的作法，模擬 $10^5$ 次發桃子呢？答案是不行，因為要是全部 $T$ 筆測試資料都無解，那每筆測試資料都得模擬 $10^5$ 次，$T$ 很大時就會花上太多時間。我們勢必要有辦法好好地判斷解是否存在。

在引理 1 的證明中，我們其實證明了這件事：

**[引理 2]**：對於正整數 $p$，定義 $k_i := p - a_i$，有辦法讓每隻猴子的桃子數量都是 $p$ **若且唯若**以下兩個條件都被滿足：
1. 存在一個整數 $t$ 滿足 $\sum c_i=tk$。
2. $0 \leq c_i \leq t$。

**[引理 2 證明結束]**

有解的條件就是存在滿足引理 2 條件的 $p$。把條件 1 展開一下，會得到 $\sum (p-a_i)=np - \sum a_i=tk$，移項得到 $\sum a_i = np - tk$，其中題目告訴我們的有 $n,k,\sum a_i$，$p,t$ 一定得是整數，根據 Bézout's identity，可以找到 $p,t$ 皆為整數的解若且唯若 $\gcd(n,k) \mid \sum a_i$。雖然找到 $p,t$ 都是整數的解不見得會滿足上述條件，但事實上這個條件就已經足以用來判斷是否有解了。

**[引理 3]**：有解若且唯若 $\gcd(n,k) \mid \sum a_i$。

**[引理 3 的證明]**

有解 $\implies \gcd(n,k) \mid \sum a_i$ 的方向剛剛證完了。我們要證明 $\gcd(n,k) \mid \sum a_i \implies$ 有解。

根據 Bézout's identity，$np-tk=\sum a_i$ 存在 $p,t$ 都是整數的解，令 $(p_0,t_0)$ 是一組任意整數解。我們想要找到的 $p,t$ 需要再滿足引理 2 的條件 2 $0 \leq c_i = p-a_i \leq t$，所以我們需要對於所有的 $i$，$p \geq a_i$、$p-t \leq a_i$，等價於 $p \geq \max a_i$ 和 $p-t \leq \min a_i$。另外我們還需要 $p,t \geq 0$，不過這個條件可以從上兩個條件推得，$p \geq \max a_i$ 可以推得 $p \geq 0$、$p-t \leq \min a_i$ 可以推得 $t \geq 0$（因為 $p \geq \min a_i$），因此不需要在意 $p,t \geq 0$ 這個條件。

令 $g=\gcd(n,k)$，任意一組整數解 $p,t$ 都可以表示成
\\[ (p_0 + m \cdot (k/g),t_0 + m \cdot (n/g)), \ m \in \mathbb{Z} \\]
$p-t$ 是 $p_0-t_0+m(k-n)/g$，注意到 $k-n<0$，因此只要取夠大的 $m$ 就可以得到滿足上述條件的 $p,t$。

**[引理 3 證明結束]**

注意還有一個特殊條件是輸入的 $k$ 是 $n$ 的倍數時，取 $\bmod n$ 之後會得到 $k=0$，代表實際上我們什麼也不能改變，這時候要直接輸出無解。

### Subtask 5 數學解 1

在證明完引理 3 之後，就可以很自然得到一個作法：找到最小的滿足 $p \geq \max a_i$、$p-t \leq \min a_i$ 的 $t$ 就是答案。令 $(p_0,t_0)$ 是一組任意整數解，可以用擴展歐幾里得演算法得出，然後我們要找到會給我們答案的 $m$（沿用引理 3 證明使用的符號）。

- $p_0 + m \cdot (k/g) \geq \max a_i$，所以 $m \geq \frac{\max a_i - p_0}{k/g}$。
- $p_0-t_0+m(k-n)/g \leq \min a_i$，所以 $m \geq \frac{\min a_i - p_0 + t_0}{(k-n)/g}$。（$k-n$ 是負的所以移項時要變號。）

這兩個下界（向上取整）取較大值就是最好的 $m$，代回去式子就能得到 $t$。

### Subtask 5 數學解 2

我們暫時先放棄找一組滿足 $np-tk = \sum a_i$ 的 $p,t$，而是先嘗試找一個答案的下界。

根據子任務 1,2，我們學到有兩種視角：發給 $k$ 隻猴子 1 顆桃子，或從 $n-k$ 隻猴子沒收 1 顆桃子。第一個視角得到的答案下界是 $(n \max a_i - \sum a_i)/k$、第二個視角得到的下界是 $(\sum a_i - n \min a_i)/(n-k)$，令這兩個數字向上取整的較大值是 $t_0$，答案只能 $\geq t_0$，一個很暴力的想法是直接暴力枚舉 $t \geq t_0$，找到最小的 $t$ 滿足 $p=(\sum a_i + tk)/n$ 是整數。

首先，有解的時候一定存在滿足條件的 $t$，而且 $[t_0,t_0+n]$ 之內一定有滿足條件的 $t$，因為 $(\sum a_i + tk) \bmod n = (\sum a_i + (t \pm n)k) \bmod n$，所以只要花 $O(n)$ 的時間就能找到目標的 $t$。

然後要證明這樣得到的 $p,t$ 會滿足合法條件。

- 因為 $t \geq (n \max a_i - \sum a_i)/k$，$p=(\sum a_i + tk)/n \geq \max a_i$。
- $p-t = (\sum a_i + tk)/n-t = (\sum a_i + t(k-n))/n=(\sum a_i - t(n-k))/n$，代入 $t \geq (\sum a_i - n \min a_i)/(n-k)$，得到 $p-t \leq \min a_i$。

這個作法也可以透過把條件中的 $p$ 替換成 $(\sum a_i+tk)/n$ 得到（也就是反過來推上面的式子）。注意到越大的 $t$ 會對應到越大的 $p$，所以把條件中的 $t$ 替換成 $(np-\sum a_i)/k$ 然後找最小的 $p$ 也可以。

### Subtask 5 模擬解

不斷發給桃子最少的猴子的方法，其實可以更有效率地維護。

根據子任務 4 的作法，每次我們會發給兩個區間的猴子各 1 顆桃子，第一個區間是所有 $< a_k$ 的 $a_i$（最後一個是 $a_x$），第二個區間是 $=a_k$ 的 $a_i$ 的最後 $k-x$ 個。考慮所有跟 $a_k$ 差最多 1 的 $a_i$，它們以後肯定都還是跟 $a_k$ 差最多 1，因此跟 $a_k$ 差最多 1 的範圍只會越來越大，如果有辦法預知下一次這個範圍改變的時間，因為這個範圍只能擴大 $n$ 次，就可以更快模擬到 $a_i$ 的全距最多是 2。

讓跟 $a_k$ 差最多 1 的範圍改變需要的發桃子次數可以直接算出來。假裝左右界在發 $t$ 次桃子後還不會改變，令區間範圍是 $[l,r)$（$l \leq k \leq r$），$m_1$ 是第一個 $=a_k$ 的 $a_{m_1}$，$m_2$ 是第一個 $=a_k+1$ 的 $a_{m_2}$（沒有的話 $m_2=r$），所以數值是 $a_k-1,a_k,a_k+1$ 的範圍分別是 $[l,m_1),[m_1,m_2),[m_2,r)$。發 $t$ 次桃子後的結果是 $i \in [1,l)$ 的 $a_i$ 都加上 $t$，然後按照以下的順序發 $(k-l+1)t$ 顆桃子，發完為止：

- $a_{m_1-1},a_{m_1-2},\dots,a_l$（這裡的都會發到）
- $a_{m_2-1},a_{m_2-2},\dots,a_l$（注意是到 $l$ 不是到 $m_1$，不一定都會發到）
- 不斷重複 $a_{r-1},a_{r-2},\dots,a_l$

做完這些事情後的任何 $a_i$ 是可以 $O(1)$ 算出來的。因為發完後區間不會改變，所以發完後要滿足 $a_{l-1} < a_k-1$、$a_k+1 < a_r$，任一條件不滿足那就代表區間會改變。二分搜會讓區間改變的最小次數，就可以花 $O(\log C)$ 的時間擴張一次區間，$C$ 是最大可能答案。維護的部分，可以和子任務 4 一樣用 `std::map` 或 stack。

在區間變成 $[1,n]$ 之後，如果全距是 2 可以先發一次桃子讓全距變成 $\leq 1$，如果還沒全部一樣的話，令現在較小的 $a_i$ 數量是 $x$，目標是找到最小的 $t$ 滿足 $tk-x$ 非負且是 $n$ 的倍數，$t$ 就是剩下需要的發桃子次數。$t$ 不會超過 $2n$，直接枚舉即可。

---

## F. Indset

### Subtask 1

首先注意到我們有以下性質 1：

**[性質 1]**：最佳解不存在連續三個元素沒被選中

**[性質 1 的證明]**

由於權重都是正的，若存在連續三個元素 $i, i + 1, i + 2$ 都沒被選，那多選 $i + 1$ 一定會比較好，矛盾。

**[性質 1 證明結束]**


有了這個我們可以考慮 dp 作法。令 $dp[i]$ 代表前 $i$ 個元素的最大權獨立集，則我們有以下初始值與轉移式：

$$
\begin{cases}
dp[i] = \emptyset & \text{if } i \leq 0 \\
dp[i] = \max(dp[i - 2] \cup \lbrace i \rbrace, dp[i - 1]) & \text{otherwise}
\end{cases}
$$

顯然可以在 $n$ 次詢問內計算完每一項 dp 值。

### Subtask 2, 3

看著 Subtask 1 的作法與 Subtask 2 的限制，心中不難會有一個方向：$[l, r]$ 的答案可能會與前綴 $[1, r]$ 的答案有高度關聯。

假設我們現在想要知道區間 $[l, r]$ 的答案，我們令 $x$ 為滿足以下條件的最小數：

- $l \leq x$
- $x$ 包含在 $dp[r]$ 裡

根據性質 1，若 $x$ 存在我們只要考慮 $x = l, x = l + 1$ 與 $x = l + 2$ 三種 case，接下來我們詳細討論各種可能的情況：

**Case 1.** $x$ 不存在

根據性質 1 可得區間 $[l, r]$ 長度至多為 2，我們只要花 $1$ 次詢問比兩個數誰大即可。

**Case 2.** $x = l$

我們宣稱答案會是：

$$
\lbrace y\,\mid\, y \in dp[r] \text{ and } l \leq y \leq r \rbrace
$$

**[Case 2 的證明]**

假設存在一個區間 $[l, r]$ 上的獨立集 $S$ 滿足 $S$ 的權重比上述的解的權重還大，那麼以下獨立集會比 $dp[r]$ 的權重還大：

$$
S \cup \lbrace y\,\mid\, y \in dp[r] \text{ and } y < l \rbrace
$$

但這與「$dp[r]$ 是所有區間 $[1, r]$ 的獨立集中權重最大的」矛盾，因此證畢。

**[Case 2 證明結束]**

**Case 3.** $x = l + 2$

我們宣稱答案會是：

$$
\lbrace y\,\mid\, y \in dp[r] \text{ and } l \leq y \leq r \rbrace \cup \lbrace l \rbrace
$$

**[Case 3 的證明]**

假設存在一個區間 $[l, r]$ 上的獨立集 $S$ 滿足 $S$ 的權重比上述的解的權重還大，那麼以下獨立集會比 $dp[r]$ 的權重還大：

$$
\lbrace y\,\mid\, y \in S \text{ and } y \neq l \rbrace \cup \lbrace z\,\mid\, z \in dp[r] \text{ and } z < l \rbrace
$$

但這與「$dp[r]$ 是所有區間 $[1, r]$ 的獨立集中權重最大的」矛盾，因此證畢。

**[Case 3 證明結束]**

**Case 4.** $x = l + 1$

這是裡面最困難的 case，而處理完其他三種 case 即可通過 Subtask 2。

首先假設我們定義 $s$ 為滿足以下條件最小的數：

- $l \leq s, s + 1 \leq r$
- $s \notin dp[r]$ 且 $s + 1 \notin dp[r]$

若不存在則 $s = r$，那我們有以下性質 2：

**[性質 2]**：存在區間 $[l, r]$ 的最大權獨立集 $S$ 滿足對於所有 $i > s$，$i \in S$ 若且為若 $i \in dp[r]$。

**[性質 2 的證明]**

假設 $S'$ 為一最大權獨立集，考慮以下兩個集合：

$$
A = \lbrace y\,\mid\, y \in S' \text{ and } y \leq s \rbrace \cup \lbrace z\,\mid\, z \in dp[r] \text{ and } z > s \rbrace
$$

$$
B = \lbrace y\,\mid\, y \in dp[r] \text{ and } y \leq s \rbrace \cup \lbrace z\,\mid\, z \in S' \text{ and } z > s \rbrace
$$

由於 $s \notin dp[r], s + 1 \notin dp[r]$，$A$ 跟 $B$ 都是獨立集。

令 $W(X)$ 代表集合 $X$ 的權重，由於 $dp[r]$ 為所有區間 $[1, r]$ 的獨立集中權重最大的，$W(B) \leq W(dp[r])$，又由於 $W(A) + W(B) = W(S') + W(dp[r])$，$W(A) \geq W(S')$，故存在一個不比 $S'$ 差且符合條件的獨立集。

**[性質 2 證明結束]**

有了性質 2 後，我們可以得知可能與 $dp[r]$ 不相同的只有位於 $[l, s]$ 的元素，且因為 $s$ 是第一個連續兩個都不選的位置，這段區間的元素在 $dp[r]$ 中會是不包含、包含、不包含這樣交替下去。

我們繼續觀察出以下性質 3：

**[性質 3]**：存在區間 $[l, r]$ 的最大權獨立集 $S$ 滿足對於所有 $i \leq s$，若 $i \in dp[r]$ 但 $i \notin S$，那麼 $i - 1 \in S$。

**[性質 3 的證明]**

假設 $S'$ 為一最大權獨立集，但存在 $i$ 滿足 $i \in dp[r], i \notin S', i - 1 \notin S'$，那麼考慮以下兩個集合：

$$
A = \lbrace y\,\mid\, y \in S' \text{ and } y < i \rbrace \cup \lbrace z\,\mid\, z \in dp[r] \text{ and } z \geq i \rbrace
$$

$$
B = \lbrace y\,\mid\, y \in dp[r] \text{ and } y < i \rbrace \cup \lbrace z\,\mid\, z \in S' \text{ and } z \geq i \rbrace
$$

由於 $i - 1 \notin dp[r], i - 1 \notin S'$，$A$ 跟 $B$ 都是獨立集。

令 $W(X)$ 代表集合 $X$ 的權重，由於 $dp[r]$ 為所有區間 $[1, r]$ 的獨立集中權重最大的，$W(B) \leq W(dp[r])$，又由於 $W(A) + W(B) = W(S') + W(dp[r])$，$W(A) \geq W(S')$，故存在一個不比 $S'$ 差且 $i$ 符合該條件的集合。我們可以反覆進行這種操作，直到沒有 $i$ 違背條件為止，且過程中集合的權重都不會變低。

**[性質 3 證明結束]**

有了性質 3 我們可以得出以下結論：

定義 $f_i$ 為 $dp[r]$ 把位於 $[l, i]$ 的選擇狀態都反轉所形成的集合（也就是說，原本在答案內就將它移除，不在就加入）。那區間 $[l, r]$ 的最大權獨立集會是以下之一：

- 所有滿足 $l \leq i < s$ 且 $i - l$ 為奇數的 $f_{i}$
- $f_s$

接下來的問題就是如何從這些可能的集合判斷出誰是最好的。我們定義序列 $d$：

$$
\begin{cases}
d_i = 0 & \text{if } i \leq 1 \\
d_i = d_{i - 2} - a_i + a_{i - 1} & \text{otherwise}
\end{cases}
$$

那第一個 case 其實就會同於找出 $d_{l - 1}, d_{l + 1}, d_{l + 3}, \ldots d_{s - 1}$ 之中最大的數字，而且將奇偶 index 分開考慮的話會發現這會是一段連續區間！因此我們需要解決的是一個「區間最大值」問題。區間最大值常見作法是使用 Sparse Table 或是線段樹等資料結構做完，但這樣只能獲得大約一半的分數，我們需要更好的作法。

對於每個右界 $r$，如果我先預處理好每個可能會是最大值的位置 $l_1, l_2, \ldots, l_k$，那麼 $d_{l_1}, d_{l_2}, \ldots, d_{l_k}$ 會是嚴格遞減的，所以每次想要詢問 $[l, r]$ 的最大值時直接找到該區間內最小的 $l_i$ 即可。而找出最大值位置們 $l_i$ 的方法相當單純：使用單調隊列就可以了。由於每個元素只會被 push 進單調隊列一次，最多也只會被 pop 一次，所以整個過程只需要 $2n$ 次判別大小即可蓋完整個單調隊列。

利用單調隊列我們可以找出上面結論所描述的第一個 case 的最佳集合，那我只要每次詢問再多花一步比它與 $f_s$ 誰大即可。

最後統整一下整個流程：

1. 對每個前綴用 dp 找出最佳解，總詢問數 $n$ 次。
2. 分別對奇數與偶數 index 蓋單調隊列以用來找出 $d$ 陣列的區間最大值，總詢問數 $2n$ 次。
3. 對於每個詢問考慮上方四種 case，最多只需要多花 $1$ 次詢問即可找出最大權獨立集。

總詢問數為 $3n + q$ 次，足以獲得滿分。

---

## G. Television

題目相當於計算將邊定向的方法，使得最後的圖沒有環，也就是變成一個**有向無環圖（DAG）**。

以下稱 $C$ 為 $n_0+n_i$ 中的最大可能值。

### Subtask 1, 2

這個子題中，給定的圖是一個 $n_0$ 或是 $n_0+n_1$ 個點的完全圖。

每個定向的方法會一一對應一種拓撲排序，因此方法數即是 $n_0!$ 或 $(n_0+n_1)!$。

時間複雜度：$O(C)$。

### Subtask 3, 4

我們延續利用拓撲排序來計算方法數的想法。

觀察到現在的圖其實是若干個 $n_0+n_i$ 個點的完全圖所構成，其中特定的 $n_0$ 個點同時出現在每個完全圖中，剩下的點互不相干。

考慮先定好中間 $n_0$ 個點的順序後再決定每個完全圖剩下的 $n_i$ 個點的順序。

中間 $n_0$ 個點的順序恰有 $n_0!$ 種。在固定中間的順序下，每個完全圖的順序有 $\frac{(n_i+n_0)!}{n_0!}$ 種，這是因為在排序 $n_0+n_i$ 個點時，有 $\binom{n_i+n_0}{n_0}$ 種決定那 $n_0$ 個中間的點**在這個完全圖的排序的位置**，而剩下的 $n_i$ 個點可以任意決定相對順序，所以全部共有
\\[\binom{n_i+n_0}{n_0}\cdot n_i!=\frac{(n_i+n_0)!}{n_0!}\\]
種方法。

因此最後的答案是
\\[n_0!\cdot\prod_{i=1}^t\frac{(n_i+n_0)!}{n_0!}\\]

而計算這個量的方式有兩種。

#### 不用模反元素

令 $dp[n]=\frac{n!}{n_0!}$，則有 $dp[n_0]=1$ 和轉移式 $dp[n]=dp[n-1]\cdot n$。因此 $dp[]$ 可以在 $O(C)$ 時間預處理。最後的答案就是 $n_0!$ 乘上許多的 $dp[n_i+n_0]$。

注意到陣列大小要至少開 $2\times 10^7$。

#### 使用模反元素

階乘可以 $O(C)$ 預處理存在陣列 $f$ 中。

關於階乘的模反元素，我們先利用費馬小定理和快速冪計算 $(2C)!$ 的模反元素，將其存在 $inv[2C]$ 中，接下來 $i!$ 的模反元素可以透過 $inv[i]=inv[i+1]\cdot (i+1)$ 從 $inv[i+1]$ 算出。因此階乘的模反元素也能 $O(C)$ 預處理。

陣列大小同樣要至少開 $2\times 10^7$。

最終時間複雜度：$O(C+t)$。


---


## H. Fingerprint

主要想法：對於每一個節點 $i$ 枚舉其不同子節點的子樹的葉節點之間的配對。

### Subtask 2

$i$ 最多只會有兩個子節點，我們稱為左節點 $l_i$ 和右節點 $r_i$，其子樹為左子樹和右子樹，令 $d_{i,j}$ 為 $i$ 子樹中第 $j$ 個葉子到 $i$ 的距離。

考慮對於每個 $i$ 計算 $ans_i=\sum_{x,y 是葉節點, LCA(x,y)=i} dist(x,y)^2$。不難看出這可以寫成

$$
\begin{array}{ll}
&\sum_j \sum_k (d_{l_i,j} + d_{r_i,k})^2\\ &=\sum_j\left(\sum_k d_{l_i,j}^2 +2 \times d_{l_i,j} \times \sum_k d_{r_i,k} + \sum_k d_{r_i,k}^2\right).
\end{array}
$$

假設葉節點到 $i$ 的距離和為 $s_i$，平方和為 $sq_i$，數量為 $c_i$，式子可以進一步簡化成 $$ans_i=c_{r_i} \times sq_{l_i} +2 \times s_{l_i} \times s_{r_i} + c_{l_i}\times sq_{r_i}$$

那該如何維護 $s_i$、$sq_i$ 和 $c_i$？

- $c_i$：數量直接加總 $\implies$ $c_i = c_{l_i} + c_{r_i}$
- $s_i$：子節點到當前節點距離和增加 1 $\implies$ $s_i = s_{l_i} + c_{l_i} + s_{r_i} + c_{r_i}$
- $sq_i$：嘗試展開一下左子樹的貢獻(右子樹應該會對稱)
    $$\sum_j(d_{l_i,j} + 1) ^ 2 = \sum_j d_{l_i,j}^2 + 2 \times \sum_j d_{l_i,j}  + \sum_j1 = ss_{l_i} +2\times s_{l_i} + c_{l_i}$$ 所以整體來說就會是 $$sq_i = (sq_{l_i} + 2 \times s_{l_i} + c_{l_i}) + (sq_{r_i} + 2 \times s_{r_i} + c_{r_i})$$

因此我們可以從任意節點出發，以樹 DP 的方式維護 $s_i$、$sq_i$ 和 $c_i$，並更新答案。

更詳細的說：
- 如果沒有子節點，$s_i = 0, sq_i=0, c_i = 1$，不用更新答案。
- 如果只有一個子節點，維護 $s_i$、$sq_i$ 和 $c_i$，不用更新答案。
- 如果有兩個子節點，維護 $s_i$、$sq_i$ 和 $c_i$，並更新答案。

複雜度 $O(\|V\| + \|E\|)$

### Subtask 3

有多個子節點該如何更新答案？

仔細看一下 Subtask 2 中，一個點 $i$ 的 $\sum_{x,y 是葉節點, LCA(x,y)=i} dist(x,y)^2$ 是如何計算的。可以看出我們只要從原本的左子樹右子樹改成倆倆的小孩子樹貢獻之和，也就是 $$ans_i=\sum_{u,v\in child(i), u<v}\left(c_{v} \times sq_{u} +2 \times s_{u} \times s_{v} + c_{u}\times sq_{v}\right)$$
但總不能直接 $O(\|child(i)\|^2)$ 枚舉小孩，所以我們要整理一下式子：

$$
\begin{array}{ll}
ans_i&=\sum_{u,v\in child(i), u<v}\left(c_{v} \times sq_{u} +2 \times s_{u} \times s_{v} + c_{u}\times sq_{v}\right)\\
&=\sum_{u,v\in child(i), u\neq v} c_u\times sq_v+\sum_{u,v\in child(i), u\neq v} s_u\times s_v\\
&=\sum_{v\in child(i)} sq_v\times(c_i-c_v)+s_i^2-\sum_{v\in child(i)} s_v^2
\end{array}
$$

如此一來我們就能在 $O(\|child(i)\|)$ 時間算出 $ans_i$。

$c_i,s_i,sq_i$ 的維護和 Subtask 2 基本上相同，把「左子樹 $+$ 右子樹」變成「每個小孩的總和」就好，這部分也是 $O(\|child(i)\|)$。

因此整體複雜度依然是 $O(\|V\|+\|E\|)$。

---

## I. Pirate

### Subtask 1, 2

先使用 Floyd-Warshall 演算法或 BFS 求出求全點對最短路徑即可，兩者的時間複雜度分別是 $O(n^3+q)$ 和 $O(n(n+m)+q)$。

### Subtask 3

存在 1000 個特殊點滿足每筆詢問必有至少一個端點是特殊點，所以要是我們知道特殊點有哪些，就可以先從每個特殊點開始 BFS、找出每個特殊點到所有點的最短路徑長，接著就可以直接回答詢問了，總時間複雜度是 $O(s(n+m)+q)$，$s$ 是特殊點數量。

唯一的問題是要怎麼找到特殊點。如果想像一張新的圖，有 $n$ 點 $q$ 邊，第 $i$ 條邊的兩端點就是第 $i$ 個詢問的兩端點，特殊點會形成這張圖的一個點覆蓋（任一條邊都有至少一個端點是特殊點），我們只要隨便找一個這張圖上的點覆蓋，當作特殊點就可以了，所以可以使用任何找點覆蓋、且找出來的點數量不會太多的方法，一種方法是用隨意的順序枚舉每一條邊，如果這條邊的兩端點都還不是特殊點，就讓兩端都是特殊點，這樣子選出來的特殊點數量會是最佳解的兩倍以內，在本題最多就是 2000。

### Subtask 4

如果我們像上個子題一樣，選出 $s$ 個特殊點、找每個特殊點到所有點的最短路徑長，其實能夠找到正確解不只有以特殊點為端點的詢問而已，只要詢問 $s,t$ 的最短路徑上有任何一個特殊點 $v$，$d(s,v)+d(v,t)$  就是答案了，因此要回答一筆詢問，計算

\\[ \min_{v \in S} \{d(s,v) + d(v,t)\} \\]

其中 $S$ 是特殊點集合，這樣就能在 $O(s(n+m))+qs)$ 的時間解決本題。

因此，重點就變成了要怎麼選出 $S$，以確保所有答案路徑上都有至少一個特殊點。題目中有一個很特殊的條件：每筆詢問的答案至少會是 $\sqrt{n}$，這代表答案路徑上至少有 $\sqrt{n}$ 個節點，因此問題是有隱藏的 $q$ 個集合，每個集合有至少 $\sqrt{n}$ 個元素，我們要找出一個集合 $S$，使得它和這 $q$ 個集合每個都有相交。這個問題有一個名字是 hitting set problem。

要是 $S$ 是從 $n$ 個節點裡面選出 $s$ 個，那麼對於一筆詢問，這筆詢問的答案路徑上**沒有**任何一個特殊點的機率是 $(1-\frac{\sqrt{n}}{n})^s$，根據 union bound，有任何一筆詢問的答案路徑上沒有任何特殊點的機率就是 $q(1-\frac{\sqrt{n}}{n})^s$，取 $s=c\sqrt{n} \ln q$ 的話，這個機率是

\\[ q\left(1-\frac{1}{\sqrt{n}}\right)^{c\sqrt{n} \ln q} \leq q \left(\frac{1}{e}\right)^{c \ln q} = \frac{1}{e^c} \\]
因為 $(1-\frac{1}{x})^x \leq 1/e$。本題中 $\sqrt{n} \ln q$ 最大值是 $1030$，如果取 $s=3000$ 就會有大約 95% 的成功率。這樣估計在 $n$ 不大的時候其實很低估成功率（$n \leq 10^4$ 算是不大），仔細計算的話，如果我們想要失敗率最多是 $\delta$，那麼我們希望的是

\\[ q\left(1-\frac{1}{\sqrt{n}}\right)^s \leq \delta \implies s \geq \frac{\log \delta - \log q}{\log (1-1/\sqrt{n})} = \frac{\log \delta^{-1} + \log q}{\log \frac{\sqrt{n}}{\sqrt{n}-1}} \\]

代入 $\delta=0.05$ 後，算出來的 $s$ 大約是 $1323$。
